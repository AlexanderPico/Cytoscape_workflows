---
title: Supplementary Protocols 1 – 3 
author: "Ruth Isserlin"
date: "`r format(Sys.Date())`"
output:
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_notebook:
    highligh: haddock
    number_sections: yes
    theme: paper
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: no
  html_document:
    highligh: haddock
    keep_md: yes
    number_sections: yes
    theme: paper
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: no
bibliography: sup_protocol1_references.bib
csl: nature-protocols.csl
---

# Background and Setup for all Supplmentary Protocols

This protocol processes RNA-seq data using the R programming environment and specialized packages from Bioconductor to create genes lists. The scripts are available for download and novice users can copy and paste commands into the R console. To create gene expression data for **Protocol step 5B**, we downloaded gene expression data from the Ovarian Serous Cystadenocarcinoma project of The Cancer Genome Atlas (TCGA)[@TCGA], http://cancergenome.nih.gov via the Genomic Data Commons (GDC) portal[@GDC] on 2017-06-14 using TCGABiolinks R package[@TCGABiolinks]. The data includes 544 samples available as RMA-normalized microarray data (Affymetrix HG-U133A), and 309 samples available as RNA-seq data, with reads mapped to a reference genome using MapSplice[@MapSplice] and read counts per transcript determined using the RSEM method[@RSEM]. RNA-seq data are labeled as ‘RNA-Seq V2’, see details at: https://wiki.nci.nih.gov/display/TCGA/RNASeq+Version+2). The RNA-SeqV2 data consists of raw counts similar to regular RNA-seq but RSEM (RNA-Seq by Expectation Maximization) data can be used with the edgeR method.


## Equipment
### Hardware requirements:
  * A recent personal computer with at least 8 gigabytes of memory (RAM).
Software requirements:
  * The R statistical computing environment (http://www.r-project.org/). We suggest using the integrated development environment RStudio (https://www.rstudio.com/).
  * Required R packages: Biobase, Limma and GSA are available from Bioconductor (https://www.bioconductor.org/)

### Data requirements:
  * Supplementary_Table10_TCGA_Microarray_rmanormalized.txt corresponds to the RMA normalized Affymetrix mRNA transcript expression data for serous ovarian cancer samples as downloaded from the GDC portal65. Normalization is required to compute differential gene expression values across subtypes, as performed in Supplementary Protocol 1A.
  * Supplementary_Table12_TCGA_RNASeq_rawcounts.txt corresponds to read counts per mRNA transcript determined using the RSEM method. These counts can be used to compare gene expression between subtypes using the edgeR analysis tool, as performed in Supplementary Protocol 1B. The counts are not pre-normalized and the normalization step using edgeR is part of the protocol.
  * Supplementary_Table11_Microarray_classdefinitions.txt and Supplementary_Table13_RNASeq_classdefinitions.txt define the subtype classification of ovarian cancer samples (immunoreactive, mesenchymal, differentiated, proliferative) (Verhaak et al.[@OV] supplementary table 1, column 3). This information is used to extract two subgroups of interest, mesenchymal and immunoreactive.

### Equipment Setup
  * Download and install R from http://cran.r-project.org/
  * Download and install RStudio from https://www.rstudio.com/ (optional, but recommended)
  * Launch R or RStudio
  * Install required Bioconductor packages. Enter the following commands in the R command line (also see https://www.bioconductor.org/install/):
  
    * source("http://www.Bioconductor.org/biocLite.R")
    * biocLite("BiocUpgrade")
    * biocLite(c("Biobase","limma",”edgeR”,”GSA”,”locfit”))
    * install.packages(c(“pheatmap”, ”RColorBrewer”, ”gProfileR”, ”RJSONIO”, ”httr”))
  * If the required packages are already installed you may receive a prompt to update these. The prompt window will ask you about updating the packages: 
  
    * Update all/some/none? [a/s/n]
    * Type ‘a’ without quotes and hit enter.
  * Load libraries into the R session using the example below. Loading of libraries is required every time R is re-opened.
  
    * library(“limma”)
  * All R files are available at https://github.com/BaderLab/EM-tutorials-docker/tree/master/R_scripts
  * Alternately, R notebooks (use R markdown and creates a notebook similar to Jupyter notebooks) of this protocol are available at https://github.com/BaderLab/Cytoscape_workflows/tree/master/EnrichmentMapPipeline

### Data setup
  * Download Supplementary Tables 10-13 to a dedicated folder of your computer. The first step of your R script will change the working directory of R to this folder. 
  * As text editors sometimes add invisible characters to text copied from PDF files, copying and pasting from this document is not recommended. The R scripts or the R notebook available in the above URLs should be used instead. 
  * Setting the current directory and loading packages (libraries) are the required first and second steps of each protocol. These are needed each time a new session is opened in R.

# Supplementary Protocol 1 – create a gene list by analyzing gene expression data from RNA-seq with edgeR

## Process RNASeq data
This part of the supplementary protocol demonstrates filtering and scoring RNA-Seq data using normalized RNA-Seq count data with the edgeR R package. The protocol can be used to produce input data for pathway enrichment methods like g:Profiler, GSEA and others. This RNA-Seq analysis protocol follows conceptually similar steps to microarray analysis shown above. 

### Load required packages
1. Load required Bioconductor packages into R. 
```{r}
knitr::opts_knit$set(cache = TRUE)

tryCatch(expr = { library("edgeR")}, 
         error = function(e) { 
           source("https://bioconductor.org/biocLite.R")
           biocLite("edgeR")}, 
         finally = library("edgeR"))

working_dir <- paste(getwd(),"data",sep="/")

#The field in the class definition file that defines the classes of the data.
data_classes <- "SUBTYPE"
```


### Load Expression Data
2. Load the expression dataset of 300 tumours, with 79 classified as Immunoreactive, 72 classified as Mesenchymal, 69 classified as Differentiated, and 80 classified as Proliferative samples. The TCGA counts data was retrieved from the GDC[@GDC] and contained counts per mRNA transcript determined using the RSEM method for 19947 transcripts and 300 samples.

```{r}
RNASeq <- read.table( 
  paste(working_dir,"Supplementary_Table12_TCGA_RNASeq_rawcounts.txt",sep="/"),  
  header = TRUE, sep = "\t", quote="\"", stringsAsFactors = FALSE)
```

### Load subtype information
3. Load subtype classification of samples. To calculate differential expression, we need to define at least two sample classes. A common experimental design involves cases and controls but any two classes can be used. The current dataset is divided into mesenchymal and immunoreactive classes (class definitions were obtained from Verhaak et al.[@OV] Supplementary Table 1, third column). After loading the matrix, check that the column names of the expression matrix and class definitions are equal.

```{r}
classDefinitions_RNASeq <- read.table( 
  paste(working_dir, "Supplementary_Table13_RNASeq_classdefinitions.txt", sep="/"), 
  header = TRUE, sep = "\t", quote="\"", stringsAsFactors = FALSE)
```

### Filter Data
4. Filter RNA-seq reads. RNA-seq data are processed following the edgeR protocol15 that filters reads based on the counts per million (CPM) statistic. RNA-seq read counts are converted to CPM values and genes with CPM > 1 in at least 50 of the samples are retained for further study (50 is the minimal sample size in the classes). This step removes genes with very low read counts that are likely not expressed in the majority of samples and cause noise in the data. Note, CPM filtering is used to remove low counts while differential gene expression analysis is based on normalized read counts which are generated below (step 6). 

```{r}
cpms <- cpm(RNASeq)
keep <- rowSums(cpms > 1) >= 50
counts <- RNASeq[keep,]
```


### Normalization and Dispersion
 
5. Data normalization, dispersion analysis is performed on the entire dataset. 
```{r}
# create data structure to hold counts and subtype information for each sample.
d <- DGEList(counts=counts, group=classDefinitions_RNASeq$SUBTYPE)

#Normalize the data
d <- calcNormFactors(d)

#create multidimensional scaling(MDS) plot.  The command below will automatically 
# generate the plot containing all samples where each subtype is a different color.  
#Ideally there should be a good separation between the different classes.
mds_output <- plotMDS(d, labels=classDefinitions_RNASeq$SUBTYPE, 
col= c("darkgreen","blue","red", "orange")[factor(classDefinitions_RNASeq$SUBTYPE)])

#calculate dispersion
d <- estimateCommonDisp(d)
d <- estimateTagwiseDisp(d)
```

### Filter unannotated genes
6. (Optional) Exclude genes with missing symbols or uncharacterized genes. In this example gene entries in the dataset containing ‘?’ or starting with LOC are excluded as they represent non-annotated genes or other loci that are not present in pathway databases.  The frequency of these and other non protein coding entries in your dataset will depend on the database used to align your RNASeq data. 
```{r}
#the below regular expression excludes gene names that are ? or that start with LOC
# any number ofadditional terms can be added to the regular expresion, for example 
# to exclude any genes that start with "His" add |^His to the regular expression
exclude <- grep("\\?|^LOC", rownames(d), value=T)
d <- d[which(!rownames(d) %in% exclude),]
```

### Calculate Differential expression
7. Differential expression analysis is performed with a simple design as described in the edgeR protocol[@edgeR].
```{r}
#calculate differential expression statistics with a simple design
de <- exactTest(d, pair=c("Immunoreactive","Mesenchymal"))
tt_exact_test <- topTags(de,n=nrow(d))

#alternately you can also use the glm model using contrasts.  
#For a simple 2 class comparison this is not required but if you want to compare
# 1 class to the remaining 3 classes then this sort of model is useful.
classes <- factor(classDefinitions_RNASeq[,data_classes])
modelDesign <- model.matrix(~ 0 + classes)

contrast_mesenvsimmuno <- makeContrasts(
                  mesenvsimmuno ="classesMesenchymal-classesImmunoreactive",
                  levels=modelDesign)
fit_glm <- glmFit(d,modelDesign)
mesenvsimmuno <- glmLRT(fit_glm , contrast = contrast_mesenvsimmuno)
tt_mesenvsimmuno <- topTags(mesenvsimmuno,n=nrow(d))

```

Examples of different designs that can be used for this dataset.  Instead of simple two class design you can also compare one class to the remaining three classes.

```{r}
classes <- factor(classDefinitions_RNASeq[,data_classes])
modelDesign <- model.matrix(~ 0 + classes)

contrast_immuno <- makeContrasts(
  immunovsrest ="classesImmunoreactive-(classesMesenchymal + 
  classesProliferative +classesDifferentiated)/3",
  levels=modelDesign)
fit_glm <- glmFit(d,modelDesign)
immunovsrest <- glmLRT(fit_glm , contrast = contrast_immuno)
tt_immunovsrest <- topTags(immunovsrest,n=nrow(d))

contrast_mesen <- makeContrasts( 
  mesenvsrest = "classesMesenchymal-(classesImmunoreactive + 
  classesProliferative +classesDifferentiated)/3",
  levels=modelDesign)
fit_glm <- glmFit(d,modelDesign)
mesenvsrest <- glmLRT(fit_glm , contrast = contrast_mesen)
tt_mesenvsrest <- topTags(mesenvsrest,n=nrow(d))

contrast_prolif <- makeContrasts( 
  prolifvsrest = "classesProliferative-(classesMesenchymal + 
  classesImmunoreactive +classesDifferentiated)/3",
  levels=modelDesign)
fit_glm <- glmFit(d,modelDesign)
prolifvsrest <- glmLRT(fit_glm , contrast = contrast_prolif)
tt_prolifvsrest <- topTags(prolifvsrest,n=nrow(d))

contrast_diff <- makeContrasts( 
  diffvsrest = "classesDifferentiated-(classesMesenchymal + 
  classesImmunoreactive +classesProliferative)/3",
  levels=modelDesign)
fit_glm <- glmFit(d,modelDesign)
diffvsrest <- glmLRT(fit_glm , contrast = contrast_diff)
tt_diffvsrest <- topTags(diffvsrest,n=nrow(d))
```

### Create g:Profiler input list
8a. Create the gene list for use in g:Profiler or another thresholded enrichment tool. The list may comprise all genes that have a significant FDR-corrected p-value (code shown below), all significant and FDR-corrected up-regulated genes and all down-regulated genes separately, or some other combination of thresholds. Also see analogous step in the microarray protocol.
```{r}
tt <- tt_exact_test

#get the indices of scored dataset that have FDR < 0.05
select_genes = which(tt$table$FDR<0.05)

#output how many genes there are in the set that have FDR<0.05
length(select_genes)

#gene names from the TCGA set contain gene name and entrez gene ids separated by ‘|’
# for all subsequent enrichment analysis we need to have just one id.  Separate the names 
# into their two ids and keep the gene symbols
topgenes_qvalue005 <- unlist(lapply(rownames(tt$table)[select_genes], 
                             function(data) {unlist(strsplit(data,"\\|"))[1]}))

#output the top 5 entries in the list of top genes
head(topgenes_qvalue005)

#write results out to the file.  This is an example of a set that can be used for
# Protocol 1
write.table(topgenes_qvalue005, "MesenchymalvsImmunoreactive_RNAseq_allsignificantgenes.txt", 
            col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)

```

### Create GSEA input list
8b. Create a two-column rank (.RNK) file of all gene IDs and corresponding scores to for GSEA pre-ranked analysis. One option is to rank genes by t-statistic of differential gene expression. GSEA will look for enrichment in the set of most differentially expressed genes at the top of the list as well as those at the bottom of the list. Genes at the top of the list are more highly expressed in class A of samples (e.g., mesenchymal) while genes at the bottom are highly expressed in class B (e.g., immunoreactive). An alternative score can be computed by multiplying direction (sign) of fold change and logarithm of p-value for each gene.
```{r}
#calculate ranks
ranks_RNAseq = sign(tt$table$logFC) * -log10(tt$table$PValue)

#gene names from the TCGA set contain gene name and entrez gene ids separated by ‘|’
# for all subsequent enrichment analysis we need to have just one id.  Separate the names 
# into their two ids.
genenames <- unlist(lapply( rownames(tt$table), function(data) 
  {unlist(strsplit(data,"\\|"))[1]}))
geneids <- unlist(lapply( rownames(tt$table),  
                          function(data) {unlist(strsplit(data,"\\|"))[2]})) 

#create ranks file
ranks_RNAseq <- cbind(genenames, ranks_RNAseq)
colnames(ranks_RNAseq) <- c("GeneName","rank")

#sort ranks in decreasing order
ranks_RNAseq <- ranks_RNAseq[order(as.numeric(ranks_RNAseq[,2]),decreasing = TRUE),]

write.table(ranks_RNAseq, paste(working_dir,
                                "Supplementary_Table2_MesenvsImmuno_RNASeq_ranks.rnk",sep="/"), 
            col.name = TRUE, sep="\t", row.names = FALSE, quote = FALSE)
```


### Create expression file

9a. Create an expression file for the enrichment map and save it to a file in the working folder. The optional expression file is similar to the expression matrix except for an additional column on the left edge of the matrix. The field often includes gene description however any text value can be added.
```{r, message=FALSE, warning=FALSE}

#fix issue with biomart not working because of url redirection
options(RCurlOptions=list(followlocation=TRUE, postredir=2L))

normalized_expression_RNAseq <- cpm(d, normalized.lib.size=TRUE)

#From the rownames parse out the gene name and the geneids
genenames <- unlist(lapply( rownames(normalized_expression_RNAseq), 
function(data) {unlist(strsplit(data,"\\|"))[1]}))
geneids <- unlist(lapply( rownames(normalized_expression_RNAseq), 
function(data) {unlist(strsplit(data,"\\|"))[2]}))

EM_expressionFile_RNAseq <- data.frame(Name = genenames, normalized_expression_RNAseq)
rownames(EM_expressionFile_RNAseq) <- rownames(normalized_expression_RNAseq)
colnames(EM_expressionFile_RNAseq) <- substring(colnames(EM_expressionFile_RNAseq),1,12)

#Add descriptions instead of geneids
tryCatch(expr = { library("biomaRt")}, 
         error = function(e) { 
           source("https://bioconductor.org/biocLite.R")
           biocLite("biomaRt")}, 
         finally = library("biomaRt"))
mart = useMart(biomart="ENSEMBL_MART_ENSEMBL")
mart = useDataset(mart, dataset="hsapiens_gene_ensembl" )

genes = getBM(attributes = c( 'hgnc_symbol', 'description'), filters='hgnc_symbol', 
              values=genenames, mart=mart);
genes$description = gsub("\\[Source.*", "", genes$description);

EM_expressionFile_RNAseq <- merge(genes,EM_expressionFile_RNAseq,  all.y=TRUE,by.x=1, by.y=1)
colnames(EM_expressionFile_RNAseq)[1] <- "Name"
colnames(EM_expressionFile_RNAseq)[2] <- "Description"

write.table(EM_expressionFile_RNAseq, 
            paste(working_dir,
                  "Supplementary_Table6_TCGA_OV_RNAseq_expression.txt", sep="/"),
            col.name=TRUE,sep="\t", row.names=FALSE, quote=FALSE)

#write out a GSEA classes file. (optional)
fileConn <- file(
  paste(working_dir,"Supplementary_Table9_TCGA_OV_RNAseq_classes.cls",sep="/"))
writeLines(c(paste(length(classDefinitions_RNASeq[,data_classes]), "4 1"), 
             paste("# ", unique(classDefinitions_RNASeq[,data_classes])[1], " ",
                   unique(classDefinitions_RNASeq[,data_classes])[2], " ",
                   unique(classDefinitions_RNASeq[,data_classes])[3], " ",
                   unique(classDefinitions_RNASeq[,data_classes])[4])), fileConn)
write.table(t(classDefinitions_RNASeq[,data_classes]), 
            paste(working_dir,"Supplementary_Table9_TCGA_OV_RNAseq_classes.cls",sep="/"), 
            col.name=FALSE, sep="\t",
            row.names=FALSE, quote=FALSE, append=TRUE)
close(fileConn)
```

### Examine results
9b. Examine gene expression data using heat maps. Heat maps can easily show the separation between sample classes, labeled by colors in the heat map header. By limiting to the most significantly differentially expressed list of genes (FDR-corrected p<0.05) we can verify whether the scoring accurately separates class A from class B. 
```{r}
tryCatch(expr = { library("pheatmap")}, 
         error = function(e) { 
          install.packages("pheatmap")}, 
         finally = library("pheatmap"))
tryCatch(expr = { library("RColorBrewer")}, 
         error = function(e) { 
          install.packages("RColorBrewer")}, 
         finally = library("RColorBrewer"))

annotation_col <- data.frame(SUBTYPE=factor(classDefinitions_RNASeq[,data_classes]))
rownames(annotation_col) <- classDefinitions_RNASeq[,2]

ann_colors = list(SUBTYPE = c(Immunoreactive="blue", Mesenchymal="red",
                              Proliferative = "orange",Differentiated="darkgreen"))
col.pal <- rev(brewer.pal(11, "RdBu"))

genes_to_select <- unlist(lapply( rownames(tt$table)[which(tt$table$FDR<0.05)], function(data) 
  {unlist(strsplit(data,"\\|"))[1]}))

matrix_for_heatmap <- as.matrix(EM_expressionFile_RNAseq[which(EM_expressionFile_RNAseq[,1] 
                            %in% genes_to_select ),3:dim(EM_expressionFile_RNAseq)[2] ])

class(matrix_for_heatmap) <- "numeric"
matrix_for_heatmap[matrix_for_heatmap == 0] <- 0.0000001
pheatmap(matrix_for_heatmap, color=col.pal, scale="row", 
         kmeans_k=NA, show_rownames=FALSE, show_colnames=FALSE, 
         main="heatmap top genes(Mesen vs Immuno)", cluster_rows=TRUE, 
         cluster_cols=FALSE, clustering_distance_rows="correlation",
         annotation_col=annotation_col, annotation_colors=ann_colors)


```

### Example of other comparisons

Example of other comparison that can be done with this dataset. Rank files for each are also created
```{r}
#Immuno vs rest
tt <- tt_immunovsrest
select_genes = which(tt$table$FDR<0.05)
length(select_genes)
topgenes_qvalue005 <- unlist(lapply( rownames(tt$table)[select_genes], 
function(data) {unlist(strsplit(data,"\\|"))[1]}))
head(topgenes_qvalue005)
write.table(topgenes_qvalue005, 
paste(working_dir,"ImmunovsRest_RNAseq_allsignificantgenes.txt",sep="/"), 
col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)

ranks_RNAseq = sign(tt$table$logFC) * -log10(tt$table$PValue)
genenames <- unlist(lapply( rownames(tt$table), function(data) 
  {unlist(strsplit(data,"\\|"))[1]}))
geneids <- unlist(lapply( rownames(tt$table),  
                          function(data) {unlist(strsplit(data,"\\|"))[2]})) 
ranks_RNAseq <- cbind(genenames, ranks_RNAseq)
colnames(ranks_RNAseq) <- c("GeneName","rank")
write.table(ranks_RNAseq, paste(working_dir,"ImmunovsRest_RNASeq_ranks.rnk",sep="/"), 
col.name = TRUE, sep="\t", row.names = FALSE, quote = FALSE)


#Mesen vs rest data
tt <- tt_mesenvsrest
select_genes = which(tt$table$FDR<0.05)
length(select_genes)
topgenes_qvalue005 <- unlist(lapply( rownames(tt$table)[select_genes], 
function(data) {unlist(strsplit(data,"\\|"))[1]}))
head(topgenes_qvalue005)
write.table(topgenes_qvalue005, 
paste(working_dir,"MesenvsRest_RNAseq_allsignificantgenes.txt",sep="/"), 
col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)

ranks_RNAseq = sign(tt$table$logFC) * -log10(tt$table$PValue)
genenames <- unlist(lapply( rownames(tt$table), function(data) 
  {unlist(strsplit(data,"\\|"))[1]}))
geneids <- unlist(lapply( rownames(tt$table),  
                          function(data) {unlist(strsplit(data,"\\|"))[2]})) 
ranks_RNAseq <- cbind(genenames, ranks_RNAseq)
colnames(ranks_RNAseq) <- c("GeneName","rank")
write.table(ranks_RNAseq, paste(working_dir,"MesenvsRest_RNASeq_ranks.rnk",sep="/"), 
col.name = TRUE, sep="\t", row.names = FALSE, quote = FALSE)

#Differentiated vs rest data
tt <- tt_diffvsrest
select_genes = which(tt$table$FDR<0.05)
length(select_genes)
topgenes_qvalue005 <- unlist(lapply( rownames(tt$table)[select_genes], 
function(data) {unlist(strsplit(data,"\\|"))[1]}))
head(topgenes_qvalue005)
write.table(topgenes_qvalue005, 
paste(working_dir,"DiffvsRest_RNAseq_allsignificantgenes.txt",sep="/"), 
col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)

ranks_RNAseq = sign(tt$table$logFC) * -log10(tt$table$PValue)
genenames <- unlist(lapply( rownames(tt$table), function(data) 
  {unlist(strsplit(data,"\\|"))[1]}))
geneids <- unlist(lapply( rownames(tt$table),  
                          function(data) {unlist(strsplit(data,"\\|"))[2]})) 
ranks_RNAseq <- cbind(genenames, ranks_RNAseq)
colnames(ranks_RNAseq) <- c("GeneName","rank")
write.table(ranks_RNAseq, paste(working_dir,"DiffvsRest_RNASeq_ranks.rnk",sep="/"), 
col.name = TRUE, sep="\t", row.names = FALSE, quote = FALSE)

#Proliferative vs rest data
tt <- tt_prolifvsrest
select_genes = which(tt$table$FDR<0.05)
length(select_genes)
topgenes_qvalue005 <- unlist(lapply( rownames(tt$table)[select_genes], 
function(data) {unlist(strsplit(data,"\\|"))[1]}))
head(topgenes_qvalue005)
write.table(topgenes_qvalue005, 
paste(working_dir,"ProlifvsRest_RNAseq_allsignificantgenes.txt",sep="/"), 
col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)

ranks_RNAseq = sign(tt$table$logFC) * -log10(tt$table$PValue)
genenames <- unlist(lapply( rownames(tt$table), function(data) 
  {unlist(strsplit(data,"\\|"))[1]}))
geneids <- unlist(lapply( rownames(tt$table),  
                          function(data) {unlist(strsplit(data,"\\|"))[2]})) 
ranks_RNAseq <- cbind(genenames, ranks_RNAseq)
colnames(ranks_RNAseq) <- c("GeneName","rank")
write.table(ranks_RNAseq, paste(working_dir,"ProlifvsRest_RNASeq_ranks.rnk",sep="/"), 
col.name = TRUE, sep="\t", row.names = FALSE, quote = FALSE)
```

# Supplementary Protocol 2 – create a gene list by analyzing gene expression data from Affymetrix microarrays with Limma

## Process Microarray data

### Load required packages
10. Load required Bioconductor packages into R
```{r}
#check to see if the library has already been installed.  If it hasn't then install it. 
tryCatch(expr = { library("Biobase")}, 
         error = function(e) { 
           source("https://bioconductor.org/biocLite.R")
           biocLite("Biobase")}, 
         finally = library("Biobase"))

tryCatch(expr = { library("limma")}, 
         error = function(e) { 
           source("https://bioconductor.org/biocLite.R")
           biocLite("limma")}, 
         finally = library("limma"))

```

Set the working directory to the location of where the Supplemental Tables 1-4 are stored. The function getwd() shows the working directory and dir() shows its files.
```{r}
working_dir <- "./data"
```

### Load Expression Data
11. Load expression data into R. Minimally the expression set requires a gene name for each row and typically at least 6 expression values (3 values in each compared class). Our dataset consists of 216 patients with 107 immunoreactive and 109 mesenchymal samples. After loading, use the command head(expressionMatrix) to verify the loaded matrix.

```{r}
expressionMatrix <- as.matrix(read.table(
  paste(working_dir, "Supplementary_Table10_TCGA_Microarray_rmanormalized.txt",sep="/"), 
  header = TRUE, sep = "\t", quote="\"", stringsAsFactors = FALSE))

```

### Load subtype information
12. Load subtype classification of samples. To calculate differential expression, we need to define at least 2 classes of samples. A common experimental design involves cases and controls but any two classes can be used. The current dataset is divided into mesenchymal and immunoreactive classes (Supplementary Table 3, third column). After loading the matrix, check that the column names of the expression matrix and class definitions are equal. 
```{r}
classDefinitions <- read.table( 
  paste(working_dir,"Supplementary_Table11_Microarray_classdefinitions.txt",sep="/"), 
  header = TRUE, sep = "\t", quote="\"", stringsAsFactors = FALSE)
identical(colnames(expressionMatrix), classDefinitions$patient)

```

### Calculate Differential expression
13. Format data and class definitions for limma. The expression data needs to be converted to an object of type ExpressionSet. The ExpressionSet needs to include a data matrix where rows are genes, columns are samples and each cell contains an expression value. Classes need to be defined as factors.
```{r}
minimalSet <- ExpressionSet(assayData=expressionMatrix)
classes <- factor(classDefinitions[,"SUBTYPE"])

```

14. Create a model matrix with the defined classes.
```{r}
modelDesign <- model.matrix(~ 0 + classes)
```

15. Fit the model to the expression matrix.
```{r}
fit <- lmFit(minimalSet, modelDesign)
```

16. Create the contrast matrix - By specifying Mesenchymal first and Immunoreactive second, positive logFC and t-values refer to higher expression levels (up-regulation) in the Mesenchenchymal versus Immunoreactive samples 
```{r}
contrastnm <- c("classesMesenchymal-classesImmunoreactive") 
contrast.matrix <- makeContrasts(
  original ="classesMesenchymal-classesImmunoreactive",
  mesenvsrest = "classesMesenchymal-(classesImmunoreactive + 
                classesProliferative +classesDifferentiated)/3",
  immunovsrest = "classesImmunoreactive-(classesMesenchymal + 
                classesProliferative +classesDifferentiated)/3",
  prolifvsrest = "classesProliferative-(classesMesenchymal + 
                classesImmunoreactive +classesDifferentiated)/3", 
  diffvsrest = "classesDifferentiated-(classesMesenchymal + 
                classesImmunoreactive +classesProliferative)/3",
  levels=modelDesign)

```

17. Model contrasts of gene expression. The following command models gene expression differences of each gene between the two groups of samples using linear regression and computes coefficients and standard errors.
```{r}
fit1 <- contrasts.fit(fit, contrast.matrix)
```

18. Compute differential expression statistics. Given a fitted linear regression model, the command generates a table containing the log fold change, average expression, t statistic, p-value, adjusted p-value and B statistic for each entity in the expression matrix using empirical Bayes statistics. The B-statistic represents the log-odds that the gene is differentially expressed but it is based on a prior assumption of how many genes are differentially expressed in the dataset. Because of its reliance on this prior assumption, the adjusted p-value is preferentially used as an indicator of significant differential expression.
```{r}
fit2 <- eBayes(fit1)
```

19. Generate a table with differentially expressed genes and adjust for multiple hypothesis testing using Benjamini-Hochberg False Discovery Rate. The table contains all genes ranked by p-value and shown with log fold change, average expression, t-statistic, p-value, adjusted p-value and B-statistic. 
```{r}
topfit <- topTable(fit2, coef="immunovsrest",number=nrow(expressionMatrix), adjust="BH")
```

### Create g:Profiler input list
20a. Create the gene list for use in g:Profiler or another thresholded enrichment tool. The list may comprise all genes that have a significant FDR-corrected p-value, all up-regulated genes with a significant FDR p-value, all down-regulated genes with a significant FDR p-value, or some other combination of thresholds.
 * To get all significant genes:
```{r}
length(which(topfit$adj.P.Val<0.05))
topgenes_qvalue005 <- rownames(topfit)[which(topfit$adj.P.Val<0.05)]
head(topgenes_qvalue005)
write.table(topgenes_qvalue005, 
"ImmunovsRest_allsignificantgenes.txt", 
col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)
```

### Examine results
 * Significantly up-regulated genes in mesenchymal samples have positive logFC and t-values.
```{r}
length(which(topfit$adj.P.Val<0.05 & topfit$t >0))
topgenes_qvalue005_mesenchymal <-
	rownames(topfit)[which(topfit$adj.P.Val<0.05 & topfit$t >0)]
head(topgenes_qvalue005_mesenchymal)
write.table(topgenes_qvalue005_mesenchymal, 
            "ImmunovsRest_immuno_significantgenes.txt", 
            col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)
```

 * Significantly up-regulated genes in immunoreactive samples have negative logFC and t-values.
```{r}
length(which(topfit$adj.P.Val<0.05 & topfit$t <0))
topgenes_qvalue005_immunoreactive<- 
  rownames(topfit)[which(topfit$adj.P.Val<0.05 & topfit$t <0)]
head(topgenes_qvalue005_immunoreactive)
write.table(topgenes_qvalue005_immunoreactive, 
  "ImmunovsRest_rest_significantgenes.txt", 
  col.names=FALSE, sep="\t", row.names=FALSE, quote=FALSE)
```

### Create GSEA input list
20b. Create a rank file for GSEA. To run GSEA in pre-ranked mode, you need a two column RNK file with gene/protein/probe name (column 1) and the associated score (column 2). The first column should contain the same type of gene IDs used in the pathway gene-set (GMT) file. GSEA looks for enrichment in the top and bottom parts of the list, ranking the file using the t-statistic. The t-statistic indicates the strength of differential expression and is used in the p-value calculation. Other scores indicating the strength of differential expression may be used as well. GSEA ranks the most up-regulated genes at the top of the list and the most down-regulated at the bottom of the list. Genes at the top of the list are more highly expressed in class A compared to class B, while genes at the bottom of the list are higher in class B. In this workflow, a positive t-value means a higher expression of a gene in the Mesenchymal samples compared to the Immunoreactive samples (variable constrastnm). The following commands create a data frame with gene IDs and t-statistics, remove lines with missing gene IDs, and store the result as a RNK file. An additional step is usually required in analysis of Affymetrix microarray data as genes are represented with multiple probesets. The most significant probeset or average probeset score may be considered for every gene.
```{r}
ranks <- data.frame(geneID=rownames(topfit),t_stat=topfit[,"t"], 
                    stringsAsFactors=F)
ranks <- ranks[which(ranks[,"geneID"] != ""),]
write.table(ranks,"ImmunovsRest_limma_ranks.rnk",
col.name=TRUE,sep="\t",row.names=FALSE, quote=FALSE)

head(ranks)
```

### Create expression file
21. Create an expression file for the enrichment map and save files to the home folder of the analysis. The expression file contains the gene IDs as the first column gene description as the second column and the expression values for each sample as the additional columns. Gene IDs should correspond to the first column of the rank file. The text files will be saved on your computer in the directory specified at the beginning of the script using setwd(). The .rnk, .cls and .txt are all tab delimited files that can be viewed in spreadsheet or in a text editor.

```{r, eval=FALSE, include=FALSE}
library(biomaRt)
mart = useMart(biomart="ensembl", dataset="hsapiens_gene_ensembl")

genes = getBM(attributes = c( 'hgnc_symbol', 'description'), filters='hgnc_symbol', 
              values=row.names(expressionMatrix), mart=mart);
genes$description = gsub("\\[Source.*", "", genes$description);

EM_expressionFile <- merge(genes,expressionMatrix,  all.y=TRUE,by.x=1, by.y=0)
colnames(EM_expressionFile)[1] <- "Name"
colnames(EM_expressionFile)[2] <- "Description"
write.table(EM_expressionFile, "TCGA_OV_expression.txt", 
	col.name=TRUE, sep="\t", row.names=FALSE, quote=FALSE)


```

# Supplementary Protocol 3 – Pathway Enrichment Analysis in R using ROAST and Camera

## Pathway Enrichment Analysis in R

### Load required packages

22. Load required Bioconductor packages into R and set working folder to the location of Supplementary Files 1-4.

```{r}
#working_dir <- “path/to/data”
working_dir <- "./data"

tryCatch(expr = { library("limma")}, 
         error = function(e) { source("https://bioconductor.org/biocLite.R")
           biocLite("limma")}, 
         finally = library("limma"))

tryCatch(expr = { library("GSA")}, 
         error = function(e) { source("https://bioconductor.org/biocLite.R")
           biocLite("GSA")}, 
         finally = library("GSA"))

tryCatch(expr = { library("RCurl")}, 
         error = function(e) { 
          install.packages("RCurl")}, 
         finally = library("RCurl"))

# This protocol can use RNA-seq expression data or microarray expression data. 
#Specify which you would like to use
dataType_rnaseq <- TRUE

#The field in the class definition file that defines the classes of the data.
data_classes <- "SUBTYPE"

#string to name the analysis
analysis_name <- "Mesen_vs_Immuno"

#from supplmentary protocol 1
expression_file <- "Supplementary_Table6_TCGA_OV_RNAseq_expression.txt"

```

23. Load in the gene sets from a GMT file.

### Download the latest pathway definition file from the updated baderlab geneset files
Only Human, Mouse and Rat gene set files are currently available on the baderlab downloads site.  If you are working with a species other than human (and it is either rat or mouse) change the gmt_url below to correct species. Check [here](http://download.baderlab.org/EM_Genesets/current_release/) to see all available species. 

This can be done automatically through R or can be done manually through the website.
To download it programmatically follow below:

```{r}
gmt_url = "http://download.baderlab.org/EM_Genesets/current_release/Human/symbol/"

#list all the files on the server
filenames = getURL(gmt_url)
tc = textConnection(filenames)
contents = readLines(tc)
close(tc)

#get the gmt that has all the pathways and does not include terms 
#inferred from electronic annotations(IEA)
#start with gmt file that has pathways only
rx = gregexpr("(?<=<a href=\")(.*.GOBP_AllPathways_no_GO_iea.*.)(.gmt)(?=\">)",
  contents, perl = TRUE)
gmt_file = unlist(regmatches(contents, rx))

dest_gmt_file <- paste(working_dir,paste("Supplementary_Table3_",gmt_file,sep="") ,sep="/")

download.file(
    paste(gmt_url,gmt_file,sep=""),
    destfile=dest_gmt_file
)

```
Load in the newly downlaoded gmt file
```{r}
#if you haven't automatically downloaded the gmt file set 
#the path to the gmt file below.
gmt_file <- dest_gmt_file

capture.output(
   genesets <- GSA.read.gmt(gmt_file),
    file="./gsea_load_output.txt"
   )

```

### Create dataset to use with Camera[@camera] and ROAST[@roast]
24. Camera[@camera] and ROAST[@roast] expect the gene sets to be a list of vectors where the slot name of each vector corresponds to the gene-set identifier, i.e. the name of the gene set however the GSA.read.gmt method loads the GMT file as an object with a list of gene set names and a list of gene sets. Add the gene set names to the gene sets vector to create a list of vectors required by ROAST[@roast] and Camera[@camera].

```{r}
names(genesets$genesets) <- genesets$geneset.names
```

25. Specify the expression dataset to be used for the analysis. You can use the MinimalSet from Supplementary protocol 1A or the DGEList variable d from Supplementary protocol 1B. For our RNAseq dataset, each row of the expression set is annotated with gene symbol and EntrezGene ID separated by “|”. To match the gene set file we need to remove the EntrezGene IDs from the row names. We choose to use gene symbols to simplify interpretation of enriched pathways and associated genes.

**(optional) Recreate the DGEList from supplementary protocol rnaseq (Steps 1 -5 in Supplementary protocol 1 rnaseq) or if you are within the same sesison you can use the d variable.**
```{r}
if(dataType_rnaseq){
      tryCatch(expr = { library("edgeR")}, 
               error = function(e) { source("https://bioconductor.org/biocLite.R")
                 biocLite("edgeR")}, 
               finally = library("edgeR"))
      
      RNAseq <- read.table( 
        paste(working_dir,"Supplementary_Table12_TCGA_RNASeq_rawcounts.txt",sep="/"), 
        header = TRUE, sep = "\t", quote="\"", stringsAsFactors = FALSE)
      classDefinitions_RNAseq <-read.table(
        paste(working_dir,"Supplementary_Table13_RNASeq_classdefinitions.txt",sep="/"),
        header = TRUE,  sep = "\t", quote="\"", stringsAsFactors = FALSE)
      
      cpms <- cpm(RNAseq)
      keep <- rowSums(cpms > 1) >= 50
      counts <- RNAseq [keep,]
      
      #round counts to create whole numbers
      counts <- round(counts)
      
      exclude <- rownames(counts)[union(grep("\\?",rownames(counts)), grep("^LOC", 
                                                              rownames(counts)))]
      counts <- counts[which(!rownames(counts) %in% exclude),]
      
      d <- DGEList(counts=counts, group=classDefinitions_RNAseq[,data_classes])
      d <- calcNormFactors(d)
      
      d <- estimateCommonDisp(d)
      d <- estimateTagwiseDisp(d)
      
      temp_names <- rownames(d)
      rownames(d) <- 
      unlist(lapply(temp_names,function(x){ unlist(strsplit(x,"\\|"))[1]}))
      
      data_for_gs_analysis <- d
      
      classes <- data_for_gs_analysis$samples$group
}
```

Or alternately load data as a MinimalSet from microarray data (Steps 9 - 14 in Supplementary protocol 2 microarray)

```{r}
if(!dataType_rnaseq){
  tryCatch(expr = { library("Biobase")}, 
         error = function(e) { 
           source("https://bioconductor.org/biocLite.R")
           biocLite("Biobase")}, 
         finally = library("Biobase"))
  
    #load in files
    expressionMatrix <- as.matrix(read.table(
      paste(working_dir, "Supplementary_Table1_TCGA_Microarray_rmanormalized.txt",sep="/"), 
      header = TRUE, sep = "\t", quote="\"", stringsAsFactors = FALSE))
    classDefinitions <- read.table( 
      paste(working_dir,"Supplementary_Table3_Microarray_classdefinitions.txt",sep="/"), 
      header = TRUE, sep = "\t", quote="\"", stringsAsFactors = FALSE)
    identical(colnames(expressionMatrix), classDefinitions$patient)
    
    #create minimal set
    minimalSet <- ExpressionSet(assayData=expressionMatrix)
    classes <- factor(classDefinitions[,data_classes])
    
    #create model
    modelDesign <- model.matrix(~ 0 + classes)
        
    #assign data set for the analysis
    data_for_gs_analysis <- minimalSet
}

```

If you haven't defined the data above using RNAseq data or microarray data, Set data to be your DGEList of MinimalSet.
```{r}
#Should be a minimalSet or DGEList
#data_for_gs_analysis <- data you want to use for the analysis.  
#classes <- class definitions for each of the samples in the dataset
```

### Filter genesets to only contain genes found in the analysis set
26. Camera[@camera] and ROAST[@roast] require that the gene sets are filtered such that all genes in gene sets have expression values in the dataset. Use function in limma (ids2indices) to convert gene identifiers in the geneset to indices in the dataset.
```{r}
genesets_filtered <- ids2indices(genesets$genesets, rownames(data_for_gs_analysis), 
remove.empty=TRUE)
```


27. Filter the gene sets according to their size, following the previous step of filtering by availability of expression data. Here we only include sets with more than 10 and less than 500 genes.
```{r}
geneset_sizes <- unlist(lapply(genesets_filtered, length))
geneset_indices <- which(geneset_sizes>=15 & geneset_sizes<200)
```

### Create design matrix and contrast
28. Create the design matrix and contrast we want to test for. In this example we are looking for pathways differential between the Mesenchymal and Immunoreactive subtypes.

```{r}

design <- model.matrix(~ 0 + classes)

contrast_mesenvsimmuno <- makeContrasts(
  mesenvsimmuno ="classesImmunoreactive-classesMesenchymal",levels=design)
```

### Run ROAST[@roast]
29. Run enrichment analysis and format the results to the ‘generic’ file format of Enrichment Map. Ths is a tab-delimited file that includes a gene set name, gene set description, p-value, FDR, phenotype and a comma-separated list of associated genes for every detected pathway. Depending on your dataset and computer, this command could take from a few minutes to an hour to run. If you receive the warning “In dnbinom(q, size = size, mu = mu, log = TRUE) : non-integer x”, the software has encountered unexpected non-integer values of gene expression, often indicating problems with upstream analysis such as suboptimal pre-processing or normalization procedures. A simple fix of rounding gene expression values may fix the error (data_for_gs_analysis$counts <- round(data_for_gs_analysis$counts)), however it should be investigated further. 
```{r}
mroast_results <- mroast(data_for_gs_analysis, genesets_filtered[geneset_indices],
                         design,contrast=contrast_mesenvsimmuno, nrot=10000)
mroast_descr <- unlist(lapply(rownames(mroast_results), 
                              function(x){unlist(strsplit(x,"\\%"))[1]}))
```


### Create generic enrichment map file from ROAST[@roast] results
30. Inspect the results returned from ROAST[@roast]. The column "Direction" shows whether the gene set is enriched for up-regulated genes or down-regulated genes. To ensure compatibility with Enrichment Map, convert these values such that 1 represents up-regulated -1 represents down-regulated genes.
```{r}
mroast_results_file <- "mroast_results_generic_em.txt"

Phenotype <- unlist(lapply(mroast_results[,"Direction"],function(x)
	{if(x=="Up"){1}else{(-1)}}))
genes <- c()
for(i in 1:length(rownames(mroast_results))){
	current_geneset <- unlist(genesets_filtered
		[ which( names(genesets_filtered) %in% rownames(mroast_results)[i])])
	current_genes <- c()
		for(j in 1:length(current_geneset)){
			if(j==length(current_geneset)){
				current_genes <- paste(current_genes, 
					rownames(data_for_gs_analysis)[current_geneset[j]], 
sep="")
			} else {
				current_genes <- paste(current_genes, 
					rownames(data_for_gs_analysis)[current_geneset[j]],
",", sep="")
			}
		}
		genes <- rbind(genes, current_genes)
	}
rownames(genes) <- rownames(mroast_results)

mroast_results_generic_em <- data.frame( rownames(mroast_results), mroast_descr, 
	PValue=mroast_results[,"PValue"], FDR=mroast_results[,"FDR"], Phenotype, genes)
write.table(mroast_results_generic_em, paste(working_dir,mroast_results_file,sep="/"), 
	col.name=TRUE, sep="\t", row.names=FALSE, quote=FALSE) 

```


### Run Camera[@camera]
31. Run pathway enrichment analysis with the Camera[@camera] R package. The analysis starts with the same files as ROAST[@roast] (see first four first steps of Supplementary Protocol 1C).
```{r}
camera_results_file <- "camera_results_generic_em.txt"


```

### Create generic enrichment map file from Camera[@camera] results

```{r}
camera_results <- camera(data_for_gs_analysis, 
	genesets_filtered[geneset_indices], design, contrast=contrast_mesenvsimmuno)
camera_descr <- unlist(lapply(rownames(camera_results), 
	function(x){unlist(strsplit(x,"\\%"))[1]}))
camera_Phenotype <- unlist(lapply(camera_results[,"Direction"], 
	function(x){if(x=="Up"){1}else{(-1)}}))


camera_genes <- c()
for(i in 1:length(rownames(camera_results))){
	current_geneset <- unlist( 
		genesets_filtered[ which( names( genesets_filtered ) %in% rownames(camera_results)[i])])
 	current_genes <- c()
	for(j in 1:length(current_geneset)){
		if(j==length(current_geneset)){
			current_genes <- paste( current_genes, 
				rownames(data_for_gs_analysis) [current_geneset[j]],
sep="")
		} else {
			current_genes <- paste( current_genes, 
				rownames(data_for_gs_analysis)[ current_geneset[j]], ",", 
sep="")
		}
	}
	camera_genes <- rbind(camera_genes, current_genes)
}
rownames(camera_genes) <- rownames(camera_results)

camera_results_generic_em <- data.frame(rownames(camera_results), camera_descr, 
	PValue = camera_results[,"PValue"], FDR=camera_results[,"FDR"], Phenotype, genes )
write.table(camera_results_generic_em, paste(working_dir,camera_results_file,sep="/"), 
	col.name=TRUE, sep="\t", row.names=FALSE, quote=FALSE)
```

### Create Enrichment Map
The results from Camera[@camera] or ROAST[@roast] can be input to Enrichment Map, following the protocol(start from step 6) in the main text.


### (Optinal) Create an Enrichment map directly from R
Optional: Build Enrichment map from the above results

Make sure that you have launch cytoscape and installed all required apps as listed in the main Protocol (Step 1 - 4)

Build a network with Camera[@camera] results:
```{r}
#use easy cyRest library to communicate with cytoscape.

tryCatch(expr = { library(RCy3)}, 
         error = function(e) { install_github("cytoscape/RCy3")}, finally = library(RCy3))

#defined threshold for GSEA enrichments (need to be strings for cyrest call)
pvalue_threshold <- "0.05"
qvalue_threshold <- "0.001"

similarity_threshold <- "0.25"
similarity_metric = "JACCARD"

generic_gmt_file <- paste(getwd(),gmt_file,sep="/")

cur_model_name <- paste("camera",analysis_name,sep="_")
results_filename <- paste(getwd(),working_dir,camera_results_file,sep="/")

#######################################
#create EM - camera results
#######################################
current_network_name <- paste(cur_model_name,pvalue_threshold,qvalue_threshold,sep="_")

em_command = paste('enrichmentmap build analysisType="generic" gmtFile=',generic_gmt_file,
                   'pvalue=',pvalue_threshold, 'qvalue=',qvalue_threshold,
                   'similaritycutoff=',similarity_threshold,
                   'coefficients=',similarity_metric,'enrichmentsDataset1=',results_filename,
                   'expressionDataset1=',paste(getwd(),working_dir,expression_file,sep="/"),
                   sep=" ")

#enrichment map command will return the suid of newly created network.
response <- commandsGET(em_command)


current_network_suid <- 0
#enrichment map command will return the suid of newly created network unless it Failed.  
#If it failed it will contain the word failed
if(grepl(pattern="Failed", response)){
  paste(response)
} else {
  current_network_suid <- response
}

response <- renameNetwork(current_network_name, as.numeric(current_network_suid))
```

When building a network if the commandGET returns an error similar to this:
"RCy3::commandsGET, HTTP Error Code: 500
 url=http://localhost:1234/v1/commands/enrichmentmap/build?analysisType=generic&gmtFile=%20/Users/risserlin/Dropbox%20(Bader%20Lab)/Ruth%20Isserlin's%20files/Sourcecode/Cytoscape_workflows/EnrichmentMapPipeline/./data/Supplementary_Table3_Human_GOBP_AllPathways_no_GO_iea_March_01_2018_symbol.gmt&pvalue=%200.05&qvalue=%200.0001&similaritycutoff=%200.25&coefficients=%20JACCARD&enrichmentsDataset1=%20/Users/risserlin/Dropbox%20(Bader%20Lab)/Ruth%20Isserlin's%20files/Sourcecode/Cytoscape_workflows/EnrichmentMapPipeline/./data/mroast_results_generic_em.txt&expressionDataset1=%20/Users/risserlin/Dropbox%20(Bader%20Lab)/Ruth%20Isserlin's%20files/Sourcecode/Cytoscape_workflows/EnrichmentMapPipeline/./data/Supplementary_Table6_TCGA_OV_RNAseq_expression.txt
Error in commandsGET(em_command) : "

Copy the url (for example from the above error use "http://localhost:1234/v1/commands/enrichmentmap/build?analysisType=generic&gmtFile=%20/Users/risserlin/Dropbox%20(Bader%20Lab)/Ruth%20Isserlin's%20files/Sourcecode/Cytoscape_workflows/EnrichmentMapPipeline/./data/Supplementary_Table3_Human_GOBP_AllPathways_no_GO_iea_March_01_2018_symbol.gmt&pvalue=%200.05&qvalue=%200.0001&similaritycutoff=%200.25&coefficients=%20JACCARD&enrichmentsDataset1=%20/Users/risserlin/Dropbox%20(Bader%20Lab)/Ruth%20Isserlin's%20files/Sourcecode/Cytoscape_workflows/EnrichmentMapPipeline/./data/mroast_results_generic_em.txt&expressionDataset1=%20/Users/risserlin/Dropbox%20(Bader%20Lab)/Ruth%20Isserlin's%20files/Sourcecode/Cytoscape_workflows/EnrichmentMapPipeline/./data/Supplementary_Table6_TCGA_OV_RNAseq_expression.txt") and paste it into a web browser to get a more descriptive error message.  Do not copy the above link to your web browser.  The url is specific to the machine you have run the notebook on. copy the url from your error message.

Sometimes the above error will come back when everything is fine.  If there are no results returned because nothing passes the thresholds you specified the above error with appear in R.  In the web browser after following the above link will show the error "Failed: None of the gene sets have passed the filter. Try relaxing the gene set filter parameters."


Build a network with the ROAST[@roast] results
```{r}

cur_model_name <- paste("roast",analysis_name,sep="_")
results_filename <- paste(getwd(),working_dir,mroast_results_file,sep="/")

#######################################
#create EM -roast results
#######################################
current_network_name <- paste(cur_model_name,pvalue_threshold,qvalue_threshold,sep="_")

em_command = paste('enrichmentmap build analysisType="generic" gmtFile=',generic_gmt_file,
                   'pvalue=',pvalue_threshold, 'qvalue=',qvalue_threshold,
                   'similaritycutoff=',similarity_threshold,
                   'coefficients=',similarity_metric,'enrichmentsDataset1=',results_filename,
                   'expressionDataset1=',paste(getwd(),working_dir,expression_file,sep="/"),
                   sep=" ")

#enrichment map command will return the suid of newly created network.
response <- commandsGET(em_command)


current_network_suid <- 0
#enrichment map command will return the suid of newly created network unless it Failed.  
# If it failed it will contain the word failed
if(grepl(pattern="Failed", response)){
  paste(response)
} else {
  current_network_suid <- response
}

response <- renameNetwork(current_network_name, network = as.numeric(current_network_suid))


```


## References
